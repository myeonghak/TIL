[Deep learning for recommender systems]


내 선호를 찾는 차량을 찾는 일은 매우 시간 소요가 크며, 큰 스트레스를 수반합니다.
한편,약 150만개의 차종이 우리의 플랫폼에 존재하는 상황에서, 매번 변화하는 차량 설명과 여전히 탐색 중인 유저들은 문제를 해결하려는 우리도 미치게 합니다.
이런 상황에서, 유저의 선호화 차량을 매칭해 주는 것은 어려운 일이며 최적의 차량을 찾았을지라도 이미 팔렸을수도 있습니다.

아직 차를 안찾아봤어도, 비슷한 문제를 뉴스, 소비재, 오락 컨텐츠에서 겪었을것. 스포티파이에서는 음악을 즐기기 전부터 음악 취향을 표현하고 싶지않음.
또, 넷플릭스의 다음 최애 시리즈를 찾을 때도 IMDB를 전부 다 뒤지고 싶지 않음. 
모든 가능성들은 선택 장애를 불러일으킴. 의사결정을 내리기 전에 모든 정보를 일일이 수집할수는 없음.
따라서 우리는 부드럽고, 개인화되며 특히 자동화된 의사결정 지원이 필요함.

사람들은 정보 과부하를 비난하곤 함. 정보 과부하는 너무 많은 정보가 우리의 사고에 침투해서, 빠르고 정확한 처리를 요구하는 것을 뜻함.
그러나 다르게 보는 관점이 있음.
2008년, 뉴욕 대학교의 교수 Clay Shirky는 "정보 과부하가 아니라, 필터의 실패다." 라고 말했음.

mobile.de에 있는 이 문구는 우리가 달성하고자 하는 것을 정확히 지적해줌.
: 정보 과부하로부터 당신을 구하기 위해 우리의 필터를 개선하고, 귀찮음 없이 딱 맞는 차를 빠르게 찾을 수 있도록 도와드립니다.  

이를 위해서, 우리는 수백만의 상호작용과 수백 가지의 특징틀로부터 유저의 선호를 유추하는 추천시스템을 사용해 개인화된 추천을 제공합니다.
아래의 그림은 이러한 추론을 나타냅니다. 인지된 정보 과부하 문제를, 디지털화의 부산물로 간주하고, 동시에 디지털화를 통해 강력해진 기법을 사용해 해결합니다.


약간의 배경지식
자세히 살펴보기 전에, 기초를 다지고 기본적인 어휘를 살펴볼 필요가 있음.
user, item, interaction이 그 중 하나임.
interaction은 명시적일수도, 암시적일수도 있음.
암시적인 interaction은 선호나 무시 표현 의도 없이 일어나는 interaction을 의미하고, 반대로 명시적인 interaction은 의도적인 선호를 반영함.

그러나, 당신이 연락하는 딜러의 차에 강한 선호를 가질 것이라고 가정할 수 있음.
이런 interaction을 평점 행렬 R에 유저 U, 아이템 I 별로 정리함.
이런 행렬은 m개의 유저 수에 해당하는 행과 n개의 아이템에 해당하는 열을 가짐. 각각의 입력값 (i,j)는 특정 interaction을 의미함. 여기서 우리는 조회,북마크,메일 받기를 다르게 구분했음.

피드백의 타입에 따라 이런 행렬은 unary할 수 있는데, 이는 오직 한가지 종류의 긍정적인 값이 피드백을 의미하는 경우를 말한다. 예를 들어 "1"만 존재하는 경우.
모든 관측불가능한 피드백은 0으로 남는다. 
추가적으로, 이러한 행렬들은 보통 매우 sparse한데, 이는 행렬의 대부분이 비어있다는 것을 의미함. 

interaction에 대한 정보에 더해, interact한 개체들에 대한 정보도 가지고 있음.
상품은 상품의 특성을 포함하고 있고, 유저-상품 interaction을 분석하면 유저가 가진 제품에 대한 선호를 이끌어 낼 수 있음.
예를 들어, 유저가 선호하는 차량 제조사를 추론할수도 있음. 
또, 유저 특화된 feature가 있을수도 있음. 유저의 단말기 혹은 연령과 같은 정보임. 우리는 이런 정보를 사용해서 추천을 개선할 수 있음.


하지만 추천 시스템은 대체 무엇을 목표로 하는가?
기본적인 목표는 미래의 user-item interaction을 과거 interaction과 feature를 사용해 예측하는 것임.
유저가 다음으로 어떤 차량을 조회하게 될지에 대한 물음표를 정량화된 숫자로 표현하는 것.
이런 목표는 추천 시스템의 relevancy로 표현되고, 이는 trustworthiness, diversity, robustness와 같은 목표 중 하나임.
scalability는 또 하나의 중요하고 제품 지향적인 목표인데, 많은 이용자에게 빠르게 추천을 제공하도록(수십~수백 밀리세컨드 내로) 우리를 강요하는 지표임. 
완벽한 추천시스템이라 할지라도 추천을 기다리는 동안 커피 한 잔 해야한다면 쓸모가 없을 것.

추천시스템의 이런 목표에 도달하는 일반적인 기법은 CF(협업필터링)임. CF는 적절한 추천 아이템을 찾기 위해 아이템과 유저간의 유사도를 사용함.
model-based Cf에서는, 유저와 아이템을 표현하는 dense matrix들을 찾아, 곱을 하면 다시 원래 행렬이 복원되는 matrix factorization 기법을 사용함.
따라서, 유저와 아이템의 저차원 표현을 찾아 예측을 만드는 데 사용할 수 있음.

차량 추천 실험에서는, 약 10만 유저와 170만 차량의 800만 평점 정보를 사용했음. 이는 가능한 10만개의 interaction 중에 5개만이 존재한다는 것을 의미함. 
이런 sparse한 정보로부터 깊은 통찰을 얻어내는 것은 아주 어렵다고 할 수 있음.
하지만 sparsity는 단지 하나의 문제에 불과함. 다른 하나는 처음 방문한 유저에게 무엇을 추천할지 모른다는 것임. 이는 cold-start 문제라고 불림.
Content-based filtering(CBF)을 사용해 이런 문제를 해결할 수 있음. 이는 유저와 아이템 특성을 사용함.
이는 추천시스템을 결측된 협업 시그널에 덜 민감하도록 만들어줌.

그러나 유저가 가진 아이템 특성에 대한 선호를 추론하는 일은, 나중에 살펴볼 예정이듯 그러한 정보를 요구함.
일반적으로, 유저와 아이템에 대한 컨텐츠 정보는 relief와 leverage 모두를 제공하지만, 여전히 어느 정도의 의존성을 갖는다.
그럼에도 불구하고, CF와 CBF 정보를 훨씬 강력해질 수 있음.
이런 추천 시스템을 hybrid recommenders라고 부름.

이제 기본적인 추천시스템 용어를 살펴보았으니, 이제 딥러닝에 대해 깊이 들어가봄.

차량 추천을 위한 딥러닝
차량 제안을 개선하기 위해 딥러닝을 사용하며, 2개의 기본적인 목표를 설정했음.

1. 추천의 유관성 늘리기
2. 확장 가능한 방식으로 제공

관측된 interaction과 user-item 특성을 사용해서 선호를 추정해야함. 

유저 u와 아이템 i가 주어졌을 때, 선호의 대리변수로써 기능하는 점수를 계산함. 이는 높은 점수는 높은 선호를 반영한다는 것을 의미.
이 점수는 유저에 대한 유관성을 아이템별로 순위매길 수 있게 해줌. 이 점수는 아이템과 interact할 유저의 가능성을 의미함.
그러므로, user-item interaction 가능성을 예측하는 것이 목적임. 이 확률을 계산하기 위해, 1개의 아웃풋 유닛을 갖는 DNN을 사용함.
이 유닛은 활성함수로 시그모이드를 사용하고, 이는 0~1 사시의 출력값을 가짐. 그러므로, 우리는 이 네트워크의 결과값을 확률로 해석할 수 있고 이는 선호와 무시 둘 중 하나로 볼 수 있음.
그러므로, 모든 가능한 user-item 조합을 0~1사이의 값으로 라벨링 할 수 있음. 결과적으로, 학습 task는 이진 분류 task로 볼 수 있음.

나이브한 접근으로, 이런 확률을 모든 가능한 user-item 조합에 대해 수행할 수 있음. 그에 기반하여, k개의 가장 적합한 아이템을 선정해 유저에게 개인화된 추천으로 제공할 수 있을 것.
그러나 추천시스템 내의 큰 수의 유저와 아이템으로 인해 실질적으로 이런 방법이 불가능함. 연산적으로 저렴하고 빠른 방법을 적용해 아이템의 묶음을 각 유저에 대해 후보 집합으로 추려내는 것이 필요함. 
이 후보 집합은 유관할 가능성이 있는 아이템을 포함한 것이어야함.

그러므로, 우리의 딥러닝 접근법을 근사적 최근접 이웃 탐색으로 증강시켰음. 우리는 이러한 탐색을 유저와 아이템에 대한 dense representation에서 수행했음. 
여기서 사용한 dense representaion은 첫번째 단계에서 수행함. 그 이후, 근사적 최근접 이웃 탐색은 빠르게 좋은 후보군을 추려낼 수 있고, 이는 좋은 확장가능성을 제공함.

CF/CBF와 같은 전통적인 기법들은 선형적인 방법으로 점수를 매기는데, 이는 잠재적인 비선형적 패턴을 찾아내지 못함.
이런 비선형성을 잡아내기 위해서, 높은 복잡도를 가진 학습 모델을 구축하려고 함. 
궁극적으로, 같은 것을 도달하고자 하지만, 저변에 깔린 모델을 바꾸려고 하는 것임. 우리의 모델은 후보군 생성을 위한 근사적 최근접 이웃 모델 탐색을 ranking을 위한 이진 분류 모델과 결합했음.

유저와 아이템 representation (특징 값들의 모음)은 실제값의 고차원인, 매우 sparse한 벡터로 제공됨. 우리는 이를 처리하기 위해 다음과 같은 작업을 요구함.

1. 임베딩
2. 후보군 생성
3. ranking

우리는 이 모든 task를 하나의 전체적인 모델로 처리함. 하지만 이는 우리 접근법의 한 부분이고, 다른 하나는 우리 데이터를 어떻게 처리하는가임.
따라서 우리 데이터를 먼저 줄지어 놓고, 모델을 다룰 필요가 있음.


데이터와 유저 선호도 발굴에 대한 짧은 이야기
첫번째 단계로, 유저와 아이템이 공통으로 갖는 피처들을 선택함.
이런 피처들을 연속형 변수(차량 가격 혹은 마일리지)와 번주형 변수(색상, 차량 타입 등)로 나눔. 그 뒤 학습용 기간과 테스트용 기간을 나눔.
이제, 정해진 기간동안 일어난 모든 이벤트와 당시 유효했던 각각의 아이템 피처를 가져옴.

이렇게 함으로써, 각각의 개인 유저의 관련된 아이템과 이벤트에만 집중할 수 있게 됨.
이는 연관된 아이템 피처의 통합 정보로써 유저의 선호를 결정할 수 있도록 해줌.
한 유저가 조회한 모든 차량의 평균과 표준편차를 계산함으로써, 선호되는 가격 범위에 대한 통찰을 얻을 수 있었을 뿐 아니라, 가격과 마일리지를 얼마나 맞바꾸는지에 대한 정보도 얻을 수 있었음.

이런 유저 representaion을 베이지안 접근법을 사용해서 얻을 수 있었고, 이를 통해 차량이 가진 피처를 유저가 가질 수 있도록 만들었음.
같은 개념으로 관련이 있다고 할지라도, 유저 representation은 stochastic하고, 반면에 차량 representation은 결정적임.
예를 들어, 차량의 특징은 빨간색, 10,000유로 처럼 정확히 정해져 있는데, 유저의 선호 색상은 0.2 빨간색, 선호 가격은 5,000~12,000 유로 등임.

이는 추론된 확률 분포에 의해 반영된, 제한된 색상에 대한 선호를 나타냄.
연속형 변수들에 대해서도 똑같이 할 수 있음.
평균과 표표준편차를 계산해서 유저의 선호 가격 범위를 추정함. 

유저의 과거 interaction에 기반한 representation을 만들 수 있음. 더 많은 유저 프로파일링을 위해, 이 포스트를 참조하라.


이제 유저와 아이템 집합을 구했으므로, 그들 간의 interaction을 타겟팅할 필요가 있음.
이진 분류 접근을 선택함으로써 이런 문제를 단순화 했음.
따라서, 선호를 표시하기 위해 모든 관측된 interaction을 1로 표시했음.
부정적인 feedback 신호가 없기 때문에, 인위적으로 negative sampling 기법을 통해 positive한 샘플로부터 생성했음.
결과적으로, 같은 양의 positive로 관측된, 그러나 겉보기엔 negative로 label된 샘플들을 얻어 냈음.


선호도 예측 모델
전체적인 네트워크는 3개의 하위 네트워크로 구성됨: UserNet, ItemNet, RankNet.
이 네트워크들은 결합되어 학습됨. 그 뒤, 추천을 실제 서빙 할 수 있는 이 전체적인 구조를 보여주기 위해 이들을 쪼갤 것임.
the recommendations in production.


1. 임베딩
UserNet과 ItemNet은 sparse한 유저와 아이템 representation u, i를 dense한 embedding e_u와 e_i로 변형함.
따라서, 정보를 압축함으로써 차원을 크게 축소함.
인간의 가독성은 잃게 되지만, 임베딩은 매우 메모리 효율적이기 때문에 이를 활용해 이후의 과정에서 이점을 얻을 수 있음. 
유저의 stochastic한 representation과 아이템의 결정적인 representation은 다르면서도 같은 피처로 연관지어져 있기 때문에, 분할된 네트워크를 사용함.

유저와 아이템에 대한 간편한 representation으로, 주어진 유저(임베딩)로부터 적절한 아이템을 선정해내는 절차를 시작할 것임.
이 프로세스는 2겹으로 구성되어 있으며, 전체 코퍼스로부터 아이템의 부분 집합을 생성해 내는 것과 그 후보군을 순위 매기는 것으로 구성되어 있음.

2. 후보군 생성
해당 유저와 유관할 가능성이 있는 후보군을 빠르게 찾기 위해, 근사적 최근접 이웃 탐색을 사용함.
유저 임베딩을 query로 사용하며, 코사인/유클리드 거리 같은 거리 척도를 사용해 t개의 가장 가까운 아이템을 효율적으로 가져올 수 있음.
이러한 기하적으로 유사한 후보군은 우리의 제안을 뽑아낼 좋은 레퍼토리를 제공함. 모든 가능한 아이템을 순위 매기는 것은 연산적으로 너무 복잡하기 때문에 이 방법은 효율적이라 할 수 있음.
근사적 최근접 이웃 탐색은 확장가능성의 핵심 열쇠가 됨.
다양한 구현 방법이 있는데, 야후의 Locally Optimized Product Quantizations(LOPQ) 혹은 스포티파이의 Erik Bernhardsson이 개발한 Approximate Nearest Neighbor Oh Yeah(ANNOY)이 있음.


3. ranking
이제 고객을 위한 t개의 아이템 후보군이 있음. RankNet을 사용해 각 후보 상품의 평점을 매길 수 있음.
최종적으로, 내림차순 스코어로 후보군을 정리하고 k개의 가장 유망한 상품을 추려냄.
이런 아이템들은 추천으로 제공될 것임. 그리고 유의미한 성공을 이뤄낼 것임.
위의 절차는 추론 절차를 묘사하고 있음.
모델을 학습하는 것은 매우 유사한데, 추가적인 후보 생성이 없을 뿐임.

결과
수많은 데이터 전처리, 치열한 모델링과 몇몇 멋진 텐서플로우 디버깅 끝에 주목할만한 결과를 만들어 냈음.
우리의 접근을 비교하기 위해, 다른 전통적인 방식을 벤치마크로 사용했음. 그리고 적절한 파라미터를 그리드서치로 결정했음.
데이터 사이언스의 양지에 있는 파이썬으로 작업하며, 우리는 LightFM을 다른 전통적인 추천 시스템을 가볍게 구현할 방법으로 추천함.
이 덕분에 딥러닝 파트에 집중할 수 있었음.

우리는 순수한 CF 모델과, CF&CBF를 결함한 hybrid 추천 모델을 베이스라인으로 삼았음.
유관도 성능을 MAP@k(Mean Average Precision)로 계산했음.
우린 다양한 k 값을 사용해서 평가를 진행했는데, 우리의 플랫폼 상황에서는 k=5가 가장 적합한 수치였음.
이 경우에는, 딥러닝 추천 모델이 전통적인 CF 모델보다 143%더 높은 성능을 보임. 
또한 강력한 hybrid 모델을 73%나 개선할 수 있었음.

전체적인 결과는 아래 그래프와 같음. MAP@5의 약 1.05%는 그다지 크게 좋아 보이지 않을지 몰라도, 두가지 포인트가 있음.
첫째, 막대한 데이터의 sparsity를 생각하면, 우리의 짧은 지속시간과 제한된 유저 부분집합이라는 제약된 상황에서 절대값의 범위는 인위적으로 낮게 유지되었음.
둘째, 중요한 지점은 상대적인 증가이며, 이 점에서 추천 유관도를 2배나 늘렸다는 것을 의미함.

그러나 유관도는 양면의 동전과 같음.
다른 목표가 아주 많음에도, 확장가능성은 이 문제에서 특히 관심사였음. 후보군 생성 덕분에 유관한 추천을 수십초 밀리초 내로 생성할 수 있었고, 이를 수백만의 유저와 아이템에 확장할 수 있었음.
꾸준한 차량 업데이트가 이를 어렵게 만들었지만, 그럼에도 확장성을 확보할 수 있었음.


결론 
딥러닝은 서비스의 더 나은 개인화를 위한 훌륭한 도구임을 확인했음. mobile.de에서 고객들이 완벽한 차를 빠르게 찾을 수 있도록 우리의 접근을 실제로 만들어내고 있음.
TensorFlow Serving을 사용하면, 모델을 간편하게 실 서비스에 서빙할 수도 있고, 매끄럽게 수정을 가할 수도 있음. 
다른 목표를 위한 모델을 구상중인데, 유저 정보를 활용해 높은 유관성을 갖는 검색 결과를 제공하도록 검색 시스템 결과를 개선하는 일이 포함됨.
앨런 퓨링의 말을 빌리자면, "We can only see a short distance ahead, but we can see plenty there that needs to be done." 
우리는 바로 앞의 짧은 거리만을 볼 수 있지만, 성취되어야 할 수 많은 일들을 볼 수 있다"

전체의 학술적인 작업은 내 깃헙 레포지터리에서 볼 수 있음.
나는 딥러닝 추천시스템을 독일 네트워크 플랫폼 XING 데이터를 사용한 직업 추천 시스템을 주제로 한 2017 RecSys Challenge에 적용하는 작업을 하고 있음.

이 멋진 연구의 교차점에서 작업하는 유일한 조직이 아님. 현재 SOTA 딥러닝 추천 시스템의 overview를 보고 싶다면, 작년의 추천시스템 컨퍼런스 발표 자료를 참고하라.
추천 시스템에 입문하는 단계라면, 미네소타 대학에서 유용한 특별과정을 코세라에서 제공하고 있음.

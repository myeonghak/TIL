[TIL] docker tutorial



1. 도커는 가상머신과는 다르게, Host OS의 커널을 공유하고 그 위에 컨테이너를 띄워 더욱 빠르게 독립된 컴퓨팅 환경을 구성함

2. 이미지: 탬플릿, 패키지와 같음. VM 템플릿과 같은 것으로 생각할 수 있음. 이미지는 한개 혹은 그 이상의 도커 컨테이너를 실행하는 데 사용될 수 있음.

3. 컨테이너: 이미지의 인스턴스로서, 독립되고, 자체적인 환경을 가짐. 

4. 이미 만들어진 도커 이미지를 가져다 쓸 수 있고, 적합한 것이 없을 경우 직접 만들어 도커허브에 올려 쓸 수 있음.

5. 기존에는 개발팀이 만든 환경을 운영팀에게 전달하여 새로 구성한 뒤 운영을 했는데, 이 작업이 도커로 간편해 짐. 바로 이 것이 도커와같은 툴이 DevOps 컬쳐에 기여한 예시로 볼 수 있음

6. docker run: 컨테이너를 시작하는 커맨드. 만약 host에 이미지가 없으면 첫번째 실행에서는 도커허브에 가서 이미지를 pull해오고, 있다면 해당 이미지를 실행함.

7. docker ps: 실행중인 도커 컨테이너를 리스트업 해줌. 도커는 자동적으로 Container ID를 할당받으며 인자로 입력해준 이름을 가지게 됨.
	docker ps -a: 실행중이지 않은 도커 컨테이너를 모두 출력해 줌. 중지되었거나(stopped), 이탈한(exited) 컨테이너도 모두 보여줌.

8. docker stop: container ID 혹은 이름을 입력해 주어 해당 컨테이너의 실행을 멈춤. 실행이 성공적으로 멈춰진다면, 입력한 컨테이너의 이름 (혹은 아이디?)을 출력함. docker ps 커맨드를 실행해보면 exited n seconds ago를 확인 가능.

9. docker rm: container ID 혹은 이름을 입력하면 해당 컨테이너를 삭제해 줌. 역시 이름(혹은 아이디?)를 반환해주면 성공적으로 제거된 것임. docker ps를 확인해보면 잘 지워진 것을 확인 가능. 그러나 도커 이미지는 그대로 있음!

10. docker image: 도커에 깔려있는 이미지의 리스트를 반환해줌.

11. docker rmi: 이미지를 제거해 줌. 실행중인 컨테이너를 모두 종료해야지만 제거 가능

12. docker run으로 한 이미지를 실행해보면, 그 이미지를 다운받은 뒤 이미지의 인스턴스인 컨테이너를 실행하고 종료함. docker ps를 보면 바로 실행이 종료된 것을 알 수 있음.왜 그럴까? 
	- 이는 도커의 컨테이너가 os를 호스팅하는 VM과는 달리, 특정한 태스크를 위한 목적을 가지기 때문임. (containers are meant to run a specific task or process) 
	- 가령 웹서버/어플리케이션서버의 한 인스턴스를 호스트하는 일, 혹은 계산 작업을 수행하거나 분석 작업을 수행하는 등.
	- 작업이 끝나면 컨테이너는 실행을 종료함 컨테이너는 그 안의 프로세스가 살아있는 동안만 살아 있음. 웹 어플리케이션이 끝나거나 죽으면 해당 컨테이너도 실행이 종료됨.
	- 그래서 우분투 컨테이너를 실행하면 바로 종료되는 것임. basic image라서 그 안의 프로세스가 없기 때문임

13. docker exec: 실행중인 도커 컨테이너에 커맨드를 실행할 때 사용됨. docker run ubuntu sleep 5를 실행하면 5초간 대기하는 상태로 컨테이너가 유지되는데, 이 때 docker exec ‘container name’ cat /etc/hosts 커맨드를 실행하면 해당 디렉토리 내의 파일을 보여주게 됨

14. docker run-attach and detach
	- 한 웹앱을 실행하면, 컨테이너 내부에서 포트를 열어두게 됨. 이는 호스트의 포트와 연결해 주어야지만 붙을 수 있음
	- 만약 그대로 실행하면 해당 터미널은 포트를 열어놓는 대기 상태로 유지하게 됨(attached mode)
	- 이 컨테이너를 detached된 상태로 가동하기 위해 docker run -d 커맨드를 사용. 이러면 바로 컨테이너 아이디만 뱉어내고 백그라운드에서만 돌아감. 바로 터미널 사용 가능
	- 도커 컨테이너의 아이디는 앞의 몇글자만 전달해주면 알아서 해당 아이디를 인지함!
	- 이 컨테이너를 다시 attach하려면 docker attach container ID 하면 됨.

15. run - tag
	run redis:4.0
	- 다른 버전의 컨테이너를 실행하고 싶다면 다음과 같은 tag를 달아주면 됨.
	- docker pull/run에서 별도의 tag를 지정해주지 않으면 기본적으로 latest가 들어가게 됨.

16. run - stdin (standard input)
	- 그냥 도커 컨테이너를 실행하면 입력값을 전달할 수 없음. 그 이유는 기본적으로 도커 컨테이너는 standard input을 listen하고 있지 않기 때문임.
	- 컨테이너의 콘솔에 붙어 있다 하더라도, 입력값을 전달할 수 없음. 입력값을 읽어들일 터미널을 가지고 있지 않은 것임.
	- 입력 값을 전달하고 싶으면, 내 host에의 standard input을 컨테이너에 전달해야(map해야) 함.
	- 도커 컨테이너와 interact하기 위해 -i라는 인자를 넣어주면 됨 (interactive mode)
	- 그런데 여기에 문제가 남아있음. 입력값을 달라는 prompt가 있어야하는데 그게 없음. 이 애플리케이션은 prompt는 터미널에서 전달됨. 그런데 우리는 컨테이너의 터미널에 연결되지 않았으므로 접근이 불가함. 이를 해결하기 위해, -t 인자를 넣어 주면 됨. (terminal)

17. run - port mapping
	- 도커가 설치된 underlying host는 docker host, docker engine이라고 불림.
	- 컨테이너에서 웹앱을 실행하면 작동이 되는것을 볼 수 있음. 그런데 유저가 여기에 붙게 하려면 어떻게 해야할까?
	- 내 앱은, port 5000으로 listen중임(my app is listening on the port 5000). 따라서 포트 5000으로 앱에 접근할 수 있을 것임.
	- 그런데 웹브라우저에서 이 포트에 접근하려면 어떤 IP를 써야할까?
	- 두가지 옵션이 있음. 첫째는 도커 컨테이너의 IP를 사용하는 방법임. 모든 컨테이너는 기본적으로 할당받는 IP주소가 있음. (eg. 172.17.0.2) 그러나 이 IP는 도커 호스트 내에서만 접근 가능함. 따라서 도커 호스트 내에서 웹 브라우저를 띄우면 접근이 가능함. 그러나 내부 IP이기 때문에 외부의 유저는 이 IP에 접근이 불가능함.
	- 외부 유저가 접근할 수 있도록 하기 위해서는, 도커호스트의 IP에 접근해야함. 그 전에, 해당 포트를 도커 호스트의 여유 포트에 맵핑해 주어야 함.
	- docker run -p 80:5000 ~ 으로 실행해주면, 내 도커 호스트의 80번 포트로 유입되는 모든 트래픽이 도커 컨테이너의 5000포트로 route될 것임.
	- 이 방식으로, 여러 컨테이너를 여러 포트에 연결해 사용할 수 있음. 또, 여러 어플리케이션(MySQL)을 여러 포트에 연결할 수 있음

18. run-volumn mapping
	- 모든 도커 컨테이너는 자기 자신만의 파일시스템을 가지고 있음. 모든 변경은 컨테이너 내부에서 이루어 짐.
	- 컨테이너를 제거하고 삭제하면, 그 컨테이너 안의 모든 데이터는 날아가게 됨.
	- 데이터 보존을 위해, 컨테이너 밖의 디렉터리와 컨테이너의 디렉터리를 맵핑 시켜줘야 함.
	- run -v 외부디렉터리:컨테이너디렉터리 옵션을 통해 이를 수행할 수 있고, 이로써 컨테이너가 삭제된다 하더라도 데이터의 변경사항을 보존할 수 있음

19. docker inspect
	- docker ps로는 부족한, 특정 컨테이너에 대한 디테일한 정보를 json형식으로 보여주는 커맨드
	- docker inspect ContainerID/name
	- state, mount, config 등의 자세한 정보를 보여줌

20. docker logs
	- 백그라운드에서 돌아가는 도커 컨테이너에 대한 정보를 확인
	- docker logs ContainerID/name

21. Docker 환경변수
	- 특정 어플리케이션의 인자값을 관리하는 효과적인 방법으로 환경변수를 사용하는 방법이 있음
	- docker run -e APP_COLOR=green simple-webapp-color
	- 여기서 green을 blue, red 등으로 바꿔가며 자유자재로 관리 가능
	- 이미 실행중인 컨테이너의 환경변수를 확인하는 방법: docker inspect container의 안에 있는 config - “Env”에서 확인할 수 있음

22. Docker Image
	- 자기만의 도커 이미지를 만들어 활용
	- 도커파일의 구조
	RUN apt-get update: 왼쪽에는 instruction, 오른쪽에는 arguments가 들어감
	- FROM os의 형식으로 시작함
	- layered architecture로 이루어짐. 순차적으로 실행되며 층층이 커맨드를 수행
	- 이러한 구조덕분에, 실행하다가 도중에 실패하더라도 그 자리에서 다시 시작할 수 있음.
	- 또, 빌드 프로세스에서 새로운 레이어를 추가하더라도 이어서 실행함
	- 도커는 빌드시 각 레이어를 캐시함. 도중에 실패하더라도 이어서 쌓음
	- 이 때문에, 소스코드와 같이 자주 변경되는 데이터로 작업할 때 유용함. 
	- 거의 모든 소프트웨어를 도커라이즈할 수 있음. 브라우저부터 스포티파이까지 모두다 가능함. 이제 따로 설치하지 않고 도커를 사용할수 있음.

23. docker CMD & Entrypoint
	- CMD command : 이 코드로 command에 해당하는 커맨드를 컨테이너 실행과 동시에 실행할 수 있음
	- 이때 command로 실행하는 작업의 뒤에 parameter를 전달할 경우, 이를 생략해도 되도록 해주는 것이 entrypoint임
	- CMD sleep 10
	- entrypoint=“sleep” 다음과 같이 되어 있음 경우, docker run ubuntu-sleeper sleep 10 대신 docker run ubuntu-sleeper 10 이렇게 지정 가능
	- default 값 지정해주기: entrypoint[“sleep”] CMD[“5”]

24. Networking in Docker 1
	- 컨테이너가 생성될 때 자동으로 세개의 네트워크를 생성함. bridge, none, host 세가지임. bridge는 컨테이너가 디폴트로 연결된 네트워크임.
	- 다른 네트워크와 연결하고 싶으면, 다음과 같은 ‘network’ parameter를 지정해 주어야 함. 
	docker run Ubuntu —network=host
	- bridge는 호스트 위의 도커에 의해 생성되는 private internal network임. 모든 컨테이너는 이 네트워크에 디폴트로 연결되어 있고, 내부적인 IP 주소를 얻음. 일반적으로 172.17.0.1같이 주어짐. 컨테이너끼리는 이 내부적인 IP를 통해 통신함.
	- 컨테이너의 외부에서 컨테이너에 접근하기 위해서는, 컨테이너의 포트를 호스트의 포트에 맵핑시켜 주어야 함.
	- 외부에서 접근하는 두번째 방법은, 컨테이너를 호스트 네트워크에 연동시키는 방법임. 이는 도커 컨테이너와 도커 호스트 사이의 어떤 고립(isolation)도 끌어낼 수 있음.
	- 가령 웹앱 컨테이너로 포트 5000번에 웹 서버를 실행하면, 포트 맵핑 없이 외부에서 접근이 가능함. 대신, 다른 컨테이너로 같은 호스트 내의 5000포트를 사용할 수 없게 됨.
	- None network에서는, 어떤 컨테이너도 아무런 네트워크에도 연결되어 있지 않음. 즉, 다른 외부네트워크나 컨테이너에 접근이 불가능함. 고립되어 있음
	- 여기서 bridge, None등 네트워크의 종류를 “driver”라고 통칭하는듯.

25. Networking in Docker 2 - user defined network
	- 만약 두개의 분리된 네트워크를 운영하고 싶다면 어떻게 해야할까? 디폴트로 생성된 bridge network 외에 다른 internal network를 생성하면 됨
	- 이는 docker network create 명령어로 실행 가능.
	- docker network ls 커맨드를 통해 현재 네트워크 상태를 확인할 수 있음.
	- 어떻게 존재하는 컨테이너에 할당된 IP 주소와 네트워크 셋팅을 확인할 수 있을까? docker inspect container를 실행하면, “NetworkSettings”에서 찾아볼 수 있음.
	
26. Networking in Docker 3 - Embedded DNS
	- 컨테이너는 각자의 이름으로 서로에게 접근할 수 있음.
	- 예를들어, 같은 노드에서 실행되고 있는 MySQL DB 컨테이너와 WebApp 서버가 있을 때, 어떻게 웹서버가 MySQL DB에 접근할 수 있을까?
	- 한가지 방법으로는, MySQL 컨테이너의 내부 IP로 접근하는 것임. 그런데 이는 이상적인 방법은 아님. 그 이유는 시스템이 리붓될때마다 같은 IP를 받는다는 보장이 없기 때문임.
	- 옳은 방법은 이름으로 접근하는 것임. 
	- 도커는 built-in DNS server를 가지고 있어, 서로를 컨테이너 명으로 접근할 수 있음(resolve each other)
	- 이 DNS 서버는 언제나 127.0.0.11의 주소에서 돌고 있음.
	- 도커는 어떻게 이러한 네트워킹을 수행하는 것일까? 어떻게 호스트 내에서 컨테이너들이 고립되어 있을까?
	- 도커는 각 컨테이너에 대해 개별적인 name space를 생성하는 network namespace를 사용함. 그 뒤 가상 이더넷 페어를 사용해 컨테이너를 연결하는 데 사용함.
	
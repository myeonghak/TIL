정렬 알고리즘

1. 선택 정렬: 
	1) 아이디어: 가장 작은 것을 앞으로 보내면 어떨까?
	2) 복잡도 N^2
	3) 처음부터 끝까지 스캔, 가장 작은 값을 정렬 마친 바로 다음 자리에 차례로 보냄



2. 버블 정렬:
	1) 아이디어: 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내면 어떨까?
	2) 복잡도 N^2 (정렬중 최악)
	3) 처음부터 끝까지 나아가는데, 1번/2번 비교해서 더 작은것을 왼쪽으로, 2/3번 비교해서 더 작은것을 왼쪽으로.. 이런 방식으로 정렬. 그럼 리스트에서 가장 큰 값(10)을 오른쪽 끝으로 보내게 됨. 그럼 이제 9개 원소에 대해서 똑같이 반복하면 됨

3. 삽입 정렬:
	1) 아이디어: 각 숫자를 적절한 위치에 삽입하면 어떨까?(‘필요할때만’ 위치 변경)
	2) 복잡도 N^2 (버블, 선택보다 나음)
	3) 왼쪽부터 순서대로 나아가는데, 왼쪽에 있는 원소들의 양 사이로 들어갈 수 있음. 왼쪽의 원소보다 작으면 그 원소의 왼쪽으로 이동. 이 방식으로, 왼쪽의 원소는 모두 정렬되었다고 믿을 수 있으므로 연산 효율화

4. 퀵 정렬:
	1) 아이디어: 특정 값을 기준으로, 큰 숫자와 작은 숫자를 나누면 어떨까?
	2) 복잡도: N*logN (최악의 경우 N^2)
	(12345678910의 경우, 분할의 이점 못누림)
	3) 피벗값 설정(보통 맨 앞) -> 피벗의 왼쪽으로 피벗보다 큰 값, 오른쪽으로 피벗보다 작은 값을 찾음->(각 최초 등장하는)큰 값과 작은 값을 서로 바꿔줌->반복하다가, 작은 값의 인덱스가 큰 값의 인덱스보다 작을 경우(엇갈릴 경우) 피벗과 작은 값의 위치를 바꿔줌 -> 이러면 피벗의 왼쪽은 다 작은 값, 오른쪽은 다 큰 값만 남음.-> 피벗을 기준으로 둘로 나뉘어서, 피벗을 각 반쪽의 첫째 원소로 지정해 같은 연산을 반복
	4) 큰 값과 작은 값을 찾는 방향만 바꾸면 내림차순 가능!

5. 힙 정렬:

6. 계수 정렬(counting sort):
	1) 아이디어:
	크기를 기준으로 개수를 세어주면 어떨까?
	2) 복잡도: O(N)
	3) 숫자의 범위가 주어진 경우 활용할 수 있음.


19.12.23
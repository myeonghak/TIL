[파이썬 자료구조와 알고리즘]

2장. 내장 시퀀스 타입

시퀀스 타입의 속성
	- 멤버십 연산: in 키워드 사용
	- 크기 함수: len(seq)
	- 슬라이싱 속성: seq[:-1]
	- 반속성(iterability): 반복문에 있는 데이터를 순회할 수 있음

파이썬의 5가지 내장 시퀀스 타입
: 문자열, 튜플, 리스트, 바이트 배열, 바이트


2.1 깊은 복사와 슬라이싱 연산
	2.1.1 가변성
	- 시퀀스(리스트, 바이트)는 가변 객체 타입임. 
	- 일반적으로 가변 객체 타입은 불변 객체 타입에 비해 비효율적임.
	- 일부 컬렉션 데이터 타입(셋, 딕셔너리 등)의 경우 불변 데이터 타입으로 인덱싱 가능. (?)
	
	- 파이썬의 모든 변수는 객체 참조(reference)임. 따라서 가변 객체를 복사할 때는 주의가 필요함
	- a=b라고 할때, a는 실제 b가 가리키는 메모리상의 위치를 뜻함.
	- 깊은 복사를 통해 (.copy() 혹은 list[:] 활용) 
	
	
	2.1.2 슬라이싱 연산자
	seq[시작]
	seq[시작:끝]
	seq[시작:끝:스텝]
	


2.2 문자열
- 파이썬은 불변의 str타입을 사용해 문자열(string)을 표현함. 이는 sequence of characters임.
- 파이썬 모든 객체에는 두가지 출력 양식이 있음.
	1) 문자열string 형식은 사람을 위해 설계됨.
	2) 표현representational 형식은 파이썬 인터프리터에서 사용하는 문자열로 보통 디버깅시 사용됨.
- 파이썬 클래스를 작성할때에는 문자열 표현을 정의하는 것이 중요.

	2.2.1 유니코드 문자열
	- 유니코드는 전세계 언어의 문자를 정의하기 위한 국제 표준 코드임.
	- 여기에는 공백, 특수문자, 수학 및 기타 기호들도 포함.
	- 모든 문자열은 일반적인 바이트가 아닌 유니코드임.
	- 문자열 앞에 u를 붙이면 유니코드 문자열을 만들 수 있음.
	
	u'잘가\u0020세상 !'
	-> '잘가 세상 !'
	
	여기서 이스케이프 시퀀스는 서수값이 0x0020인 유니코드 문자를 나타냄.
	일반적인 아스키 코드의 표현은 7비트(이 아스키를 확장한 ANSI 코드는 8비트)가 필요,
	유니코드 표현에는 16비트가 필요함.
	
	2.2.2 문자열 메서드
	
	1) join()
	A.join(B)는 리스트 B에 있는 모든 문자열을 하나의 단일 문자열 A로 결함.
	+ 기호를 사용하는 것보다 효율적이라고 함.
	"".join(reversed(slayer))처럼 사용 가능.
	reversed 메서드는 그대로 사용하면 list로 나오지 않는데 위처럼 사용 가능하다는 것.
	
	2) ljust(), rjust()
	A.ljust(width, fillchar): 맨처음부터 width만큼 fillchar를 채움. rjust는 반대임.
	
	3) format()
	문자열에 변수를 추가하거나 포맷팅 사용됨
	
	
	4) 문자열 언패킹
	
	함수로 전달하기 적합한 키-밸류 딕셔너리가 생성됨.
	
	5) splitlines()
	-> 문자열을 줄바꿈 문자 기준으로 분리한 결과를 리스트로 반환
	
	6) split()
	스트링을 구분자를 기준으로 구분해준 리스트를 반환
	
	7) strip()
	A.strip(B)는 A 문자열 "앞뒤"의 B 문자열을 제거함. 즉 스페이스바만 제거할 수 있는게 아니라, 다른거 모두 가능!!
	-> rstrip, lstrip도 있음.
	
	8) swapcase()
	-> 대소문자를 반전함 
	
	9) find와 index
	-> 원하는 스트링의 시작 인덱스를 반환함. 
	-> index는 없으면 에러를 일으키는데, find는 없으면 -1을 반환하는 차이점이 있음.
	-> rindex, rfind는 오른쪽에서부터 탐색함
	
	
	10) replace(old, new, maxreplace) 메서드
	-> maxreplace는 바꿔줄 최대 갯수를 지정. 
	
	
2.3 튜플
튜플은 쉼표로 구분된 값으로 이루어지는 불변 시퀀스 타입

	2.3.1 튜플 메서드
	
	1) A.count(x)
	-> 튜플의 원소 갯수를 반환
	
	2) A.index(x)
	-> 원소의 인덱스를 반환
	
	2.3.2 튜플 언패킹
	모든 iterable 객체는 시퀀스 언패킹 연산자 *를 사용해 언패킹 가능.
	
	2.3.3 네임드 튜플
	- collections의 시퀀스 데이터 타입
	- 일반 튜플과 비슷한 성능과 특성을 가짐
	- 그러나 인덱스 위치 뿐만 아니라 이름으로도 참조 가능
	
2.4 리스트
- 배열은 연속된 메모리에 순차적으로 저장됨
- 연결 리스트는 분리된 노드가 서로 연결되어 있음.
- 순회iteration에서는 두 자료구조 모두 똑같은 효율성을 가짐
- 그러나 직접 접근할 때 배열의 경우 O(1)의 복잡도, 연결 리스트에서는 O(n)의 복잡도를 가짐. 이는 처음부터 순회를 해나가며 접근해야 하기 때문.
- 삽입할때는 연결리스트의 경우 O(1), 배열의 경우 O(n)임. 이는 연결 리스트는 연결된 가운데 위치에 앞뒤를 연결해주면 되지만, 배열의 경우 하나씩 밀어내 주어야하므로 O(n)이 됨

- 파이썬에서는 리스트가 배열과 유사함. 리스트는 크기를 동적으로 조정할 수 있는 배열임.
- 연결리스트와는 관련이 없음. 


- 항목 추가, 제거: append, pop 사용 & 시간복잡도 O(1)
- remove, index, insert, in을 사용한 멤버십 테스트는 시간 복잡도 O(n)임.

- 검색 및 멤버십 테스트 시 빠른 속도가 필요할 경우 set/dict를 사용하는게 나을수 있음.

	2.4.1 리스트 메서드
	1) append()
	2) extend():
	- append와 같지만 iterable을 각각 쪼개어서 element를 넣어줌.
	- 이는 + 연산자를 사용하는 것과 동일한 효과.
	
	3) insert()
	4) remove()
	5) pop()
	6) del문
	-> 리스트 인덱스를 지정해 특정 항목을 삭제함.
	-> 슬라이스를 사용해 특정 범위 항목들을 삭제할 수도 있음.
	-> 이렇게 객체 참조가 삭제되고 다른 객체가 더이상 그 데이터를 참조하지 않을 때, 파이썬은 그 데이터 항목을 가비지 컬렉터에 수집
	7) index()
	8) count()
	-> 리스트에 특정 항목이 몇개 들어있는지 갯수를 반환
	9) sort(key, reversed=True)
	-> key에는 함수가 들어감.
	
	2.4.2 리스트 언패킹
	
	
	2.4.3 리스트 컴프리헨션
	
	


[리스트 메서드의 복잡도 정리]
n: 리스트의 총 항목 수
k: 연산(조회 및 추가) 항목의 수

인덱스 [] 접근: 	O(1)
인덱스 할당: 		O(1)
append():		O(1)
pop():			O(1)
pop(i):			O(n)
insert(i,항목):	O(n)
del 연산자:		O(n)
삽입:				O(n)
멤버십 테스트 in:	O(n)
슬라이스[x:y]조회:	O(k)
슬라이스 삭제:		O(n)
슬라이스 할당:		O(n+k)
reverse():		O(n)
연결(concat): 	O(k)
sort():			O(n logn)
곱하기:			O(nk)

* 슬라이스 할당:
sdsd=[1,2,3]
sdsd[4:5]=[2,3]




	
	